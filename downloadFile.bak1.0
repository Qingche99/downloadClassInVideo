/*
IDE:GoLand
PackageName:main
FileName:downloadFile.go
UserName:QH
CreateDate:2023/10/26
*/
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
)

var (
	fileName = "ClassIn平台课节视频汇总_20231024111956_1021998.csv"
	dList    []classInfo
)

type classInfo struct {
	filePath    string
	downloadUrl string
}

func main() {
	openCsv(fileName)
	multiThreadedDownload(dList)

}

// 递归创建文件夹
func mkDir(path string) {
	err := os.MkdirAll(path, 0777)
	if err != nil {
		fmt.Println("创建文件夹失败:", err)
		return
	}
	//fmt.Println("文件夹创建成功")
}

// 字符串删除\n\t
func stringRmNT(strContent string) string {

	retStrN := strings.ReplaceAll(strContent, "\n", "")
	retStrT := strings.ReplaceAll(retStrN, "\t", "")
	return retStrT
}

// 打开csv文件
func openCsv(filePath string) {
	// 打开CSV文件
	file, err := os.Open(filePath)
	if err != nil {
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close()

	// 创建一个CSV reader
	reader := csv.NewReader(file)

	// 读取所有行
	rows, err := reader.ReadAll()
	if err != nil {
		fmt.Println("读取CSV文件失败:", err)
		return
	}
	readRows(rows)
}

// 读取二维切片
func readRows(rows [][]string) {

	keys := []string{"classId", "courseId", "courseName", "className", "classStart", "classEnd", "teacher", "videoTime", "videoId", "url"} // keys
	fileRot := fileName[0 : len(fileName)-4]
	lastId := ""
	n := 1
	// 遍历每一行并输出
	for _, eachRow := range rows {
		eachDownMap := make(map[string]string)
		if !strings.HasPrefix(eachRow[9], "http") {
			continue
		}
		// 遍历键切片
		for i := 0; i < len(keys); i++ {
			// 检查值切片是否越界
			if i < len(eachRow) {
				eachDownMap[keys[i]] = eachRow[i]
			} else {
				eachDownMap[keys[i]] = ""
			}

		}

		if lastId == eachDownMap["classId"] {
			//fmt.Println(row[0], downMap["classId"])
			n++
		} else {
			lastId = eachDownMap["classId"]
			n = 1
		}
		//fmt.Println(eachRow[0], n)

		classId := eachDownMap["classId"]
		courseName := stringRmNT(eachDownMap["courseName"])
		className := eachDownMap["className"]
		url := eachDownMap["url"]
		mkPath := fmt.Sprintf("./%s/%s", fileRot, courseName) // 拼接课程文件夹路径
		mkDir(mkPath)
		dirPath := fmt.Sprintf("%s/%s-%s-%d.mp4", mkPath, classId, className, n)

		//fmt.Println(dirPath, url)
		var info classInfo

		info.downloadUrl = url
		info.filePath = stringRmNT(dirPath)

		dList = append(dList, info)

	}

}

// 多线程下载文件，需传输下载的切片列表
func multiThreadedDownload(downloadSlice []classInfo) {
	var wg sync.WaitGroup
	wg.Add(len(downloadSlice))
	for _, v := range downloadSlice {
		go func(info classInfo) {
			defer wg.Done()

			resp, err := http.Get(info.downloadUrl)
			if err != nil {
				fmt.Println("下载文件失败:", err)
				return
			}
			defer resp.Body.Close()

			downloadFilePath := info.filePath

			if _, err := os.Stat(downloadFilePath); os.IsNotExist(err) { // 检查文件是否存在

				out, err := os.Create(downloadFilePath)
				if err != nil {
					fmt.Println("创建文件失败:", err)
					return
				}
				defer out.Close()

				_, err = io.Copy(out, resp.Body)
				if err != nil {
					fmt.Println("写入文件失败:", err)
				} else {
					fmt.Println("下载并保存文件:", downloadFilePath)
				}
			} else {
				fmt.Printf("文件已存在，忽略: %s\n", downloadFilePath)
			}

		}(v)
	}

	wg.Wait()
	fmt.Println("全部文件下载完成。")
}
